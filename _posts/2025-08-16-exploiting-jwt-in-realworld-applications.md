---
layout: post
title: "Exploiting JWT Misconfigurations in Real-World Applications"
section: blog
---

### TL;DR  
While performing AppSec reviews on our internal products, I repeatedly encountered JWT implementations with <span class="highlight">subtle but critical misconfigurations</span> ‚Äî things like `alg: none` acceptance, weak or fallback secrets, algorithm confusion between symmetric and asymmetric keys, and missing claim validation. These <span class="highlight">mistakes can enable complete authentication bypass</span>, long-lived token replay, or privilege escalation. This post walks through what I found, how I validated the issues, and practical fixes you can apply today.

---

## üß† Introduction

JSON Web Tokens (JWTs) are ubiquitous for stateless authentication and API authorization. Their portability and simplicity make them attractive, but those same qualities mean that <span class="highlight">small mistakes in generation or verification become powerful attack vectors</span>.

During routine AppSec reviews of our internal services, I traced token issuance and verification logic, inspected deployment manifests, and tested token handling end-to-end. The intent of this write-up is to share concrete, realistic patterns I saw in production-like environments, how they translate into <span class="highlight">attack paths, and how teams can avoid them</span>.

---

## üîç Common JWT Misconfigurations I Encounter

### 1) `alg: none` acceptance  
Some verification flows <span class="highlight">did not explicitly reject tokens</span> that declared `"alg": "none"`. If a server accepts such tokens, an attacker can <span class="highlight">strip the signature and submit a tampered payload that the backend treats as authentic</span>.

This is not theoretical: misconfigured verification libraries or permissive verification flags are usually the root cause.  
Result: trivial <span class="highlight">authentication bypass and user impersonation</span>.

---

### 2) Hardcoded, weak, or fallback HMAC secrets  
I saw secrets present in code, example `.env` files, and configuration fallbacks such as `"secret"`, `"admin123"`, or `"changeme"`. Worse, some services relied on an <span class="highlight">environment fallback instead of failing fast</span> when the secret was not provided.

How I found them:
- scanning repo configs and `.env.example` files
- reviewing container images and deployment manifests
- searching code for `os.getenv`-style fallbacks

---

### 3) Asymmetric / symmetric key confusion (RS256 vs HS256)  
Some services intended to use RS256 but accidentally passed the public key into HMAC verification or allowed algorithm downgrades. If the server is not <span class="highlight">strict about the algorithm, an attacker can sign a token using public key material</span> and have it accepted. Root causes include mixing verification code across environments and reusing configuration variables incorrectly.

---

### 4) Frontend trust without server-side enforcement  
<span class="highlight">Frontends parsing JWTs to decide UI state</span> or show "admin" options without verifying the token server-side can leak sensitive information or present false privileges. While proper APIs often still <span class="highlight">enforce backend checks, client-side trust confuses threat boundaries and creates potential for information disclosure</span>.

---

## üß™ How I Identified & Validated These Issues

Practical steps I used during internal reviews:

- **Code inspection:** search for <span class="highlight">token creation/verification, secrets, and fallback values</span> in service repos.
- **Infrastructure review:** validate <span class="highlight">Helm charts, Kubernetes manifests, and CI/CD pipelines to ensure secrets are injected</span> properly.
- **Token crafting:** use [jwt.io](https://jwt.io) or small scripts to <span class="highlight">decode and build tokens; change claims and re-sign</span> where necessary.
- **Brute-force checks:** run <span class="highlight">short-wordlist checks against HMAC-signed tokens</span> when weak secrets were suspected.
- **Traffic interception:** use Burp Suite to <span class="highlight">swap Authorization headers with forged tokens</span> and observe endpoint behavior.
- **Algorithm tests:** attempt `alg: none` and algorithm <span class="highlight">downgrades (HS<->RS) against verification endpoints</span>.

All testing was done in authorized contexts against internal or staging environments per our AppSec policy ;)

---

## üîí Case Study: A Secret That Shouldn‚Äôt Have Been

While reviewing an internal authentication microservice as part of a scheduled AppSec review, I traced how tokens were issued and verified. In the token utility module I found:

```python
JWT_SECRET = os.getenv("JWT_SECRET", "s3cr3t")
````

Using environment variables with a local fallback is common for development, but I validated the deployment pipeline and Helm chart and discovered that the <span class="highlight">production manifest did not set `JWT_SECRET`</span>. The service was therefore using the fallback `"s3cr3t"` in production as the HMAC signing key.

To confirm the impact, I crafted a token payload with an admin role and reasonable timestamps, signed it locally using `"s3cr3t"`, and submitted it to an admin-level API endpoint. The backend <span class="highlight">accepted the token and granted elevated privileges</span>.

This issue was caused by multiple operational gaps:

* CI/CD had no gate to fail <span class="highlight">deployments when a required secret was missing</span>.
* The code <span class="highlight">used a non-fatal fallback value instead of failing fast</span> on missing configuration.
* No startup-time assertion existed to <span class="highlight">prevent the service from running with insecure defaults</span>.

Takeaway: Secrets must <span class="highlight">never have insecure defaults</span>. Infrastructure-as-code and CI should <span class="highlight">enforce presence and strength of critical secrets</span>, and services should <span class="highlight">refuse to start if essential secrets are missing</span>.

Mitigations I applied with the team:

* Remove insecure fallbacks from code; require explicit configuration for production.
* Add a CI pre-deploy check that fails if `JWT_SECRET` is missing or matches common weak patterns.
* Rotate the secret, invalidate tokens, and redeploy with proper secret management (secrets manager + Kubernetes secret mounted securely).
* Add runtime assertion: exit startup if critical secrets are not present.

---

## üìå Conclusion

JWTs are powerful tools for stateless authentication, but small implementation mistakes make them fragile. During AppSec reviews of our internal products I saw the same patterns repeat: defaults left in code, missing infrastructure checks, algorithm confusion, and lax claim validation.

<span class="highlight">Security is not a checkbox ‚Äî it‚Äôs an operational discipline.</span> Require strong configuration gating, validate everything on the backend, and bake JWT verification checks into both code and deployment pipelines. Doing so reduces the chance that a trivial oversight becomes a critical incident.

---

üßµ *Thanks for reading! If you‚Äôre working with JWTs, take a moment to review your configs and make sure no insecure defaults are slipping through. And if you‚Äôd like to swap ideas or collaborate on building safer authentication systems, I‚Äôd love to connect.*